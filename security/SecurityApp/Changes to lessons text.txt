A1 - Injection
---------------

Example Of Attack

Login to the insecure-web-app
In the employee id search field, type in the following: 1%3B INSERT INTO EMPLOYEE (FIRSTNAME, LASTNAME, TITLE, DISABLED, JMBG) VALUES ('JAMES', 'BOND', 'SPY', 0, 007)
Click search
Delete everything from employee id search field and search again
James Bond has infiltrated your database as one of the employees :O

Analysis Of The Attack

Find the file EmployeeController.cs and in it find the following method:
  
  [HttpGet("search/{Empid}")]
  public async Task<IActionResult> EmployeeSearch(string Empid)
    {
        string query = "SELECT * FROM Employee WHERE EmployeeId = " + Empid;
        var EmpDeatils = await _context.Employee.FromSql(query).ToListAsync();

		return Json(EmpDeatils);
    }
		
This method is responsible for retrieving employee from the database and is the main enabler of security injection.

Task: Prevent Injection

Approach 1 (GOOD): Instead of concatenating query strings, use prepared statements. This will take care of SQL injection attempts.

Approach 2 (THE BEST, WHEN AVAILABLE): Use the parametrized query with Entity Framework (WHERE EmployeeId = @p0) to search for employee by id. Validation is done implicitly.


A2 - Broken Authentication and Session Management
-------------------------------------------------

Task: Prevent Attack

Code that is needed for encrypting passwords is in HashingPasswords.cs class but since we need to do that once(all existing accounts are stored in file) it is commented out. Since we are not using database, crypted passwords are again stored in file.


A3 - Cross-Site Scripting (XSS)
-------------------------------

Task: Prevent The XSS Attack

AngularJS 2 has its own script sanitization. Reason that it is not activated is that we are using a custom directive *zPrint in SecurityApp\solution\SecurityApp\ClientApp\app\components\home\home.component.html

The way to fix this is to not use the custom directive but use existing Angular way of binding values.

You can replace  <span *zPrint="empData.firstName"></span>, with {{empData.firstName}}. This will use Angular sanitization.

In general you should always use framework XSS sanitization. If the framework does not support XSS sanitization you can use following:

In JAVA use HtmlUtils.htmlEscape method to sanitize user inputs.
In .NET use System.Web.Security.AntiXss.AntiXssEncoder class to sanitize user inputs.


A4 - Insecure Direct Object reference
---------------------------------------


A6 - Sensitive Data Exposure
----------------------------

Analysis Of The Attack

Find the file Employee.java. The employee class should have this field present:

public string JMBG { get; set; }

This is all fine, but we need to find a way to not leak this field into the HTTP responses that return employees.

Task: Prevent Sensitive Data Exposure

Instruct the JSON serializer to ignore the sensitive field. This can often be done declaratively (e.g. in the Net apps using annotations).


A7 - Missing Function Level Access Control
------------------------------------------

Task: Prevent The Missing Function Level Access Control Attack

Find and fix the back end service by enforcing proper authorization of the delete user action. Make it available to admin users only.

Hint: there is an annotation provided by ASP.NET Core that can be used to fix the issue. 
[Authorize(Roles = "ADMIN")] // This is put on controller or action

A8 - Cross-Site Request Forgery (CSRF)
---------------------------------------

Example Of Attack

Login to the SecurtyApp
Leave it open
Go to the folder exploit
Run exploit\run.bat file
Click on the prize :-)
Go back to the SecurityApp user page and you will see no user is present anymore

Analysis Of The Attack

If you open the exploit\index.html you will see this function

``` function callDelete() {   for (let i = 1; i < 10; i++) {
                var url = "http://localhost:53348/api/employee/remove/" + i;
                
                var xhttp = new XMLHttpRequest();
                xhttp.open("DELETE", url, true);
				xhttp.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
				xhttp.send();
            }
}
} ```

It calls the DELETE verb on the http://localhost:53348/api/employee/remove/{id} endpoint, and this deletes the user.

Task: Prevent The CSRF Attack

Have a look into the OWASP documentation and understand how to fix this using the CSRF anti forgery token.

Hint: Enable global cors policy for ASP.NET core app and remove AllowAllHeaders. See here: https://damienbod.com/2017/05/09/anti-forgery-validation-with-asp-net-core-mvc-and-angular/